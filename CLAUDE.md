# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

TableMate is a Next.js 16 application for creating curated menu experiences with allergy transparency and democratic dessert voting. Hosts manage dish libraries and events, while guests respond via magic link invitations (no account required).

## Development Commands

```bash
# Development
npm run dev              # Start dev server at http://localhost:3000
npm run build            # Production build
npm start                # Start production server
npm run lint             # Run ESLint

# Testing
npm test                 # Run Playwright tests (headless)
npm run test:ui          # Interactive test UI
npm run test:headed      # Run tests with visible browser
npm run test:debug       # Debug mode with Playwright Inspector
npx playwright test tests/landing-page.spec.ts  # Run specific test file
npx playwright show-report  # View test results
```

## Architecture

### Authentication Flow

- **Hosts**: Google OAuth via Supabase Auth
  - Sign in at landing page → OAuth callback → redirected to `/host`
  - Server-side session management with cookie-based auth

- **Guests**: Magic token authentication (no account required)
  - Access via URL with `?token=xxxxx` parameter
  - Token validated in Server Actions using service role key
  - Pattern: `app/guest/actions.ts` validates token before mutations

### Supabase Client Pattern

Two separate client configurations:

1. **Server Components** (`lib/supabase/server.ts`):
   - Uses `createServerClient` with cookie handling
   - Async `createClient()` function (requires `await`)
   - Respects RLS policies based on authenticated user

2. **Client Components** (`lib/supabase/client.ts`):
   - Uses `createBrowserClient` for interactive features
   - Synchronous initialization
   - Used in forms, real-time updates, image uploads

3. **Server Actions** (`app/guest/actions.ts`):
   - Uses service role key directly for magic token validation
   - Bypasses RLS to verify guest tokens
   - Pattern: Verify token → Perform operation → Update guest status

### Data Flow

**Guest Selection Submission:**
1. Guest component calls Server Action with magic token
2. Action verifies token matches guest + event
3. Upsert to `selections` table (main course)
4. Upsert to `dessert_votes` table (dessert)
5. Update `guests.has_responded = true`

**Host Event Management:**
1. Host creates dishes in library (with images in Supabase Storage)
2. Creates event with arrays of dish IDs: `appetizer_ids`, `main_dish_ids`, `dessert_ids`
3. Adds guests with emails → auto-generated `magic_token`
4. Event page fetches dishes by ID arrays to display menu

### Database Schema Key Points

- All dish/event IDs are UUIDs stored in PostgreSQL array columns
- Magic tokens: 32-byte random hex strings (auto-generated by DB)
- RLS policies: Hosts access via `auth.uid()`, guests via magic token verification
- Image storage: `dish-images` bucket with public read, authenticated write

### Type Safety

- `types/database.ts` defines complete schema as TypeScript types
- Generated types include `Row`, `Insert`, `Update` for each table
- Supabase clients are typed: `createClient<Database>()`
- Ensures compile-time checking of queries and mutations

### App Router Structure

```
app/
├── page.tsx                        # Landing page (public)
├── layout.tsx                      # Root layout with auth context
├── api/auth/callback/route.ts      # OAuth callback handler
├── host/
│   ├── page.tsx                    # Dashboard (protected)
│   └── events/
│       ├── new/page.tsx            # Event creation form
│       └── [eventId]/page.tsx      # Event details + guest invitations
└── guest/
    ├── actions.ts                  # Server Actions for guest mutations
    └── [eventId]/page.tsx          # Guest RSVP flow (magic token auth)
```

### Component Organization

- `components/host/`: Host-only features (DishForm, EventForm, OrderSummary, etc.)
- `components/guest/`: Guest-facing UI (GuestMenuGallery)
- `components/AuthButton.tsx`: Shared sign-in/sign-out component

## Environment Variables

Required in `.env.local`:
- `NEXT_PUBLIC_SUPABASE_URL`: Supabase project URL
- `NEXT_PUBLIC_SUPABASE_ANON_KEY`: Public anon key
- `SUPABASE_SERVICE_ROLE_KEY`: Service role key (server-side only)
- `NEXT_PUBLIC_APP_URL`: Application URL

## Testing

12 Playwright tests covering:
- Landing page UI and content
- Authentication flows and redirects
- Accessibility (headings, semantic HTML, keyboard navigation)
- Responsive design (mobile, tablet, desktop viewports)

Tests use Page Object Model pattern when appropriate. Dev server auto-starts before tests via `webServer` config.

## Database Setup

Complete SQL schema in `SETUP.md`. Key steps:
1. Create all tables with RLS enabled
2. Set up trigger for profile creation on auth signup
3. Create storage bucket `dish-images` with policies
4. Configure Google OAuth in Supabase dashboard

## Common Patterns

**Fetching dishes for an event:**
```typescript
const { data: dishes } = await supabase
  .from('dishes')
  .select('*')
  .in('id', event.main_dish_ids)  // PostgreSQL array query
```

**Image uploads:**
- Client uploads to Supabase Storage bucket `dish-images`
- Returns public URL
- URL saved in `dishes.image_url` column

**Guest invite links:**
```typescript
const inviteUrl = `${process.env.NEXT_PUBLIC_APP_URL}/guest/${eventId}?token=${guest.magic_token}`
```

## Security Considerations

- All tables use Row Level Security (RLS)
- Hosts can only access their own dishes/events via `auth.uid()`
- Guests cannot manipulate other guests' data (verified in Server Actions)
- Service role key only used in Server Actions, never exposed to client
- Magic tokens are 32-byte random values (256-bit entropy)

## Tech Stack

- **Framework**: Next.js 16 (App Router)
- **Language**: TypeScript 5
- **Styling**: Tailwind CSS v4
- **Database**: Supabase (PostgreSQL with RLS)
- **Auth**: Supabase Auth (Google OAuth + magic tokens)
- **Storage**: Supabase Storage
- **Testing**: Playwright
